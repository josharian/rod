package main

import (
	"errors"
	"flag"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

// benchmarks returns a list of all benchmark functions in the named files.
func benchmarks(dir string, files []string) ([]string, error) {
	var bb []string
	fset := token.NewFileSet()
	for _, file := range files {
		path := filepath.Join(dir, file)
		f, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return nil, err
		}

		// What name is "testing" imported under?
		var tname string
		for _, s := range f.Imports {
			if s.Path.Value != `"testing"` {
				continue
			}
			if tname != "" {
				return nil, errors.New("testing imported twice")
			}
			if s.Name == nil {
				tname = "testing"
				continue
			}
			tname = s.Name.Name
		}
		if tname == "" {
			continue // no benchmarks without testing.B
		}

		// Locate benchmarks.
		for _, d := range f.Decls {
			fn, ok := d.(*ast.FuncDecl)
			if !ok {
				continue
			}
			if isBenchmark(tname, fn) {
				bb = append(bb, fn.Name.Name)
			}
		}
	}

	return bb, nil
}

// isBenchmark reports whether fn is a benchmark function declaration.
// testing is the name that the testing package with imported under.
func isBenchmark(testing string, fn *ast.FuncDecl) bool {
	if !isBenchmarkName(fn.Name.String()) ||
		fn.Recv != nil ||
		fn.Type.Results != nil ||
		fn.Type.Params == nil ||
		len(fn.Type.Params.List) != 1 {
		return false
	}

	// Check that the type of the param is *testing.B.
	star, ok := fn.Type.Params.List[0].Type.(*ast.StarExpr)
	if !ok {
		return false
	}
	sel, ok := star.X.(*ast.SelectorExpr)
	if !ok || sel.Sel.Name != "B" {
		return false
	}
	id, ok := sel.X.(*ast.Ident)
	return ok && id.Name == testing
}

// isBenchmarkName reports whether name could be the name of a test function.
func isBenchmarkName(name string) bool {
	const prefix = "Benchmark"
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) { // Just "Benchmark" is ok
		return true
	}
	r, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(r)
}

func gen(pkg *build.Package, xtest bool, files []string) error {
	bb, err := benchmarks(pkg.Dir, files)
	if err != nil {
		return err
	}
	if len(bb) == 0 {
		return nil
	}

	var suffix string
	if xtest {
		suffix = "_x"
	}
	f, err := os.Create(filepath.Join(pkg.Dir, "benchserv"+suffix+"_test.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	dot := struct {
		Package    string
		Benchmarks []string
	}{
		Package:    pkg.Name,
		Benchmarks: bb,
	}
	if xtest {
		dot.Package += "_test"
	}

	return tmpl.Execute(f, dot)
}

func main() {
	flag.Parse()
	paths := flag.Args()
	if len(paths) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	for _, path := range paths {
		pkg, err := build.Import(path, ".", 0)
		if err != nil {
			log.Fatal(err)
		}
		if err := gen(pkg, false, pkg.TestGoFiles); err != nil {
			log.Fatal(err)
		}
		if err := gen(pkg, true, pkg.XTestGoFiles); err != nil {
			log.Fatal(err)
		}
	}
}

// Man, I sure do wish issue 9969 would get fixed.
var (
	raw = `\
// Autogenerated by github.com/josharian/rod

package {{.Package}}

import (
	"testing"

	"github.com/josharian/rod/server"
)

func TestStartRodServer(*testing.T) {
	server.Start()
}

func init() {
	server.Register([]server.Benchmark{
{{range .Benchmarks}}\
		{Name: "{{.}}", F: {{.}}},
{{end}}\
	})
}
`
	nonewline = strings.Replace(raw, "\\\n", "", -1)
	tmpl      = template.Must(template.New("benchserve").Parse(nonewline))
)
